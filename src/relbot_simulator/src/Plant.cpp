/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  Plant.cpp
 *  subm:  Plant
 *  model: Relbot_Model_Final_Si_hiltest
 *  expmt: Relbot_Model_Final_Si_hiltest
 *  date:  February 4, 2025
 *  time:  2:13:59 PM
 *  user:  Universiteit Twente
 *  from:  -
 *  build: 5.1.1.13146
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
/* Include the header for memcpy and memset
 * You may need to change this into <memory.h> for older compilers
 */
#include <string.h>

/* 20-sim include files */
#include "Plant.h"

/* Delta margin used for end time checking */
const XXDouble c_delta = 1.0e-7;

/* this PRIVATE function sets the input variables from the input vector */
void Plant::CopyInputsToVariables (XXDouble *u)
{
	/* copy the input vector to the input variables */
	m_V[90] = u[0];		/* steer_left */
	m_V[91] = u[1];		/* steer_right */

}

/* this PRIVATE function uses the output variables to fill the output vector */
void Plant::CopyVariablesToOutputs (XXDouble *y)
{
	/* copy the output variables to the output vector */
	y[0] = 	m_V[87];		/* a_pos_feedback_left */
	y[1] = 	m_V[88];		/* b_pos_feedback_right */
	y[2] = 	m_V[85];		/* c_position_x {m} */
	y[3] = 	m_V[86];		/* d_position_y {m} */
	y[4] = 	m_V[89];		/* e_theta_z {rad} */

}

Plant::Plant(void)
{
	m_number_constants = 0;
	m_number_parameters = 36;
	m_number_initialvalues = 14;
	m_number_variables = 92;
	m_number_states = 14;
	m_number_rates = 14;
	m_number_matrices = 24;
	m_number_unnamed = 22;

	/* the variable arrays */
	m_C = new XXDouble[0 + 1];		/* constants */
	m_P = new XXDouble[36 + 1];		/* parameters */
	m_I = new XXDouble[14 + 1];		/* initial values */
	m_V = new XXDouble[92 + 1];		/* variables */
	m_s = new XXDouble[14 + 1];		/* states */
	m_R = new XXDouble[14 + 1];		/* rates (or new states) */
	m_M = new XXMatrix[24 + 1];		/* matrices */
	m_U = new XXDouble[22 + 1];		/* unnamed */
	m_workarray = new XXDouble[20 + 1];

	Reset(0.0);
	m_finish_time = 550.0;
}

void Plant::Reset(XXDouble starttime)
{
	m_start_time = starttime;
	m_step_size = 0.001;
	m_time = starttime;
	m_major = true;
	m_stop_run = false;

	/* Clear the allocated variable memory */
	memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_P, 0, (36 + 1) * sizeof(XXDouble));
	memset(m_I, 0, (14 + 1) * sizeof(XXDouble));
	memset(m_V, 0, (92 + 1) * sizeof(XXDouble));
	memset(m_s, 0, (14 + 1) * sizeof(XXDouble));
	memset(m_R, 0, (14 + 1) * sizeof(XXDouble));
	memset(m_M, 0, (24 + 1) * sizeof(XXDouble));
	memset(m_U, 0, (22 + 1) * sizeof(XXDouble));
	memset(m_workarray, 0, (20 + 1) * sizeof(XXDouble));


	state = initialrun;
}

bool Plant::IsFinished(void)
{
	return (state == finished);
}

Plant::~Plant(void)
{
	/* free memory */
	delete[] m_C;
	delete[] m_P;
	delete[] m_I;
	delete[] m_V;
	delete[] m_s;
	delete[] m_R;
	delete[] m_M;
	delete[] m_U;
	delete[] m_workarray;
}

/* the initialization function for submodel */
void Plant::Initialize (XXDouble *u, XXDouble *y, XXDouble t)
{
	/* initialization phase (allocating memory) */
	m_initialize = true;
	m_stop_run = false;

	/* set the constants */


	/* set the parameters */
	m_P[0] = 0.021;		/* Drivetrain_left\DeadZone1\zone */
	m_P[1] = -12.0;		/* Drivetrain_left\DutycycleToVolt\K */
	m_P[2] = 0.003240977777777778;		/* Drivetrain_left\Gain\K */
	m_P[3] = 0.0246;		/* Drivetrain_left\gy_motor_constant_left\r */
	m_P[4] = 3.5005237381150026e-6;		/* Drivetrain_left\J_rotor_left\i */
	m_P[5] = 2.14;		/* Drivetrain_left\R_actuator_left\r */
	m_P[6] = 3.33348e-6;		/* Drivetrain_left\R_rotational_friction_left\r */
	m_P[7] = 0.06417777777777778;		/* Drivetrain_left\tf_gearbox_reduction_left\r */
	m_P[8] = 0.021;		/* Drivetrain_right\DeadZone2\zone */
	m_P[9] = -12.0;		/* Drivetrain_right\DutycycleToVolt\K */
	m_P[10] = 0.003240977777777778;		/* Drivetrain_right\Gain\K */
	m_P[11] = 0.0246;		/* Drivetrain_right\gy_motor_constant_right\r */
	m_P[12] = 3.5005237381150026e-6;		/* Drivetrain_right\J_rotor_right\i */
	m_P[13] = 2.14;		/* Drivetrain_right\R_actuator_right\r */
	m_P[14] = 3.33348e-6;		/* Drivetrain_right\R_rotational_friction_right\r */
	m_P[15] = 0.06417777777777778;		/* Drivetrain_right\tf_gearbox_reduction_right\r */
	m_P[16] = 1.0e-4;		/* Rigid_body\c_x_left\spring */
	m_P[17] = 1.0e-4;		/* Rigid_body\c_x_right\spring */
	m_P[18] = 1.0e-4;		/* Rigid_body\c_y_left\spring */
	m_P[19] = 1.0e-4;		/* Rigid_body\c_y_right\spring */
	m_P[20] = 0.072388;		/* Rigid_body\J_RELbot\i */
	m_P[21] = 1.288;		/* Rigid_body\m_RELbot\m */
	m_P[22] = 100.0;		/* Rigid_body\r_x_left\r */
	m_P[23] = 100.0;		/* Rigid_body\r_x_right\r */
	m_P[24] = 100.0;		/* Rigid_body\r_y_left\r */
	m_P[25] = 100.0;		/* Rigid_body\r_y_right\r */
	m_P[26] = 0.0;		/* ly_offset */
	m_P[27] = 0.02;		/* lx_offset */
	m_P[28] = -0.104;		/* Rigid_body\tf_wheel_left_wrt_CoM\r */
	m_P[29] = 0.06175;		
	m_P[30] = 0.104;		/* Rigid_body\tf_wheel_right_wrt_CoM\r */
	m_P[31] = 0.06175;		
	m_P[32] = 0.008;		/* Wheel_left\R_rotational_friction_left\r */
	m_P[33] = 0.0505;		/* Wheel_left\tf_rotation_to_translation_left\r */
	m_P[34] = 0.008;		/* Wheel_right\R_rotational_friction_right\r */
	m_P[35] = 0.0505;		/* Wheel_right\tf_rotation_to_translation_right\r */


	/* set the initial values */
	m_I[0] = 0.0;		/* Drivetrain_left\Integrate\initial */
	m_I[1] = 0.0;		/* Drivetrain_left\J_rotor_left\state_initial */
	m_I[2] = 0.0;		/* Drivetrain_right\Integrate\initial */
	m_I[3] = 0.0;		/* Drivetrain_right\J_rotor_right\state_initial */
	m_I[4] = 0.0;		/* Rigid_body\AngleBody\initial */
	m_I[5] = 0.0;		/* Rigid_body\c_x_left\state_initial */
	m_I[6] = 0.0;		/* Rigid_body\c_x_right\state_initial */
	m_I[7] = 0.0;		/* Rigid_body\c_y_left\state_initial */
	m_I[8] = 0.0;		/* Rigid_body\c_y_right\state_initial */
	m_I[9] = 0.0;		/* Rigid_body\InertialPosition\initial1 */
	m_I[10] = 0.0;		/* Rigid_body\InertialPosition\initial2 */
	m_I[11] = 0.0;		/* Rigid_body\J_RELbot\state_initial */
	m_I[12] = 0.0;		/* Rigid_body\m_RELbot\state_initial */
	m_I[13] = 0.0;		


	/* set the states */
	m_s[0] = m_I[0];		/* Drivetrain_left\Integrate\output */
	m_s[1] = m_I[1];		/* Drivetrain_left\J_rotor_left\state */
	m_s[2] = m_I[2];		/* Drivetrain_right\Integrate\output */
	m_s[3] = m_I[3];		/* Drivetrain_right\J_rotor_right\state */
	m_s[4] = m_I[4];		/* Rigid_body\AngleBody\output {rad} */
	m_s[5] = m_I[5];		/* Rigid_body\c_x_left\state */
	m_s[6] = m_I[6];		/* Rigid_body\c_x_right\state */
	m_s[7] = m_I[7];		/* Rigid_body\c_y_left\state */
	m_s[8] = m_I[8];		/* Rigid_body\c_y_right\state */
	m_s[9] = m_I[9];		/* Rigid_body\InertialPosition\initial1_int */
	m_s[10] = m_I[10];		/* Rigid_body\InertialPosition\initial2_int */
	m_s[11] = m_I[11];		/* Rigid_body\J_RELbot\state */
	m_s[12] = m_I[12];		/* Rigid_body\m_RELbot\state */
	m_s[13] = m_I[13];


	/* set the matrices */
	m_M[0].mat = &m_V[30];		/* Rigid_body\InertialPosition\output */
	m_M[0].rows = 2;
	m_M[0].columns = 1;
	m_M[1].mat = &m_V[32];		/* Rigid_body\m_RELbot\p.f */
	m_M[1].rows = 2;
	m_M[1].columns = 1;
	m_M[2].mat = &m_V[34];		/* Rigid_body\m_RELbot\i */
	m_M[2].rows = 2;
	m_M[2].columns = 2;
	m_M[3].mat = &m_V[44];		/* Rigid_body\PowerDemuxLeft\input.e */
	m_M[3].rows = 2;
	m_M[3].columns = 1;
	m_M[4].mat = &m_V[48];		/* Rigid_body\PowerDemuxLeft1\input.e */
	m_M[4].rows = 2;
	m_M[4].columns = 1;
	m_M[5].mat = &m_V[52];		/* Rigid_body\PowerDemuxRight\input.e */
	m_M[5].rows = 2;
	m_M[5].columns = 1;
	m_M[6].mat = &m_V[56];		/* Rigid_body\PowerDemuxRight1\input.e */
	m_M[6].rows = 2;
	m_M[6].columns = 1;
	m_M[7].mat = &m_V[59];		/* Rigid_body\RTF\p1.f */
	m_M[7].rows = 2;
	m_M[7].columns = 1;
	m_M[8].mat = &m_V[61];		/* Rigid_body\RTF\r */
	m_M[8].rows = 2;
	m_M[8].columns = 2;
	m_M[9].mat = &m_V[70];		/* Rigid_body\tf_wheel_left_wrt_CoM\p2.f */
	m_M[9].rows = 2;
	m_M[9].columns = 1;
	m_M[10].mat = &m_P[28];		/* Rigid_body\tf_wheel_left_wrt_CoM\r */
	m_M[10].rows = 2;
	m_M[10].columns = 1;
	m_M[11].mat = &m_V[73];		/* Rigid_body\tf_wheel_right_wrt_CoM\p2.f */
	m_M[11].rows = 2;
	m_M[11].columns = 1;
	m_M[12].mat = &m_P[30];		/* Rigid_body\tf_wheel_right_wrt_CoM\r */
	m_M[12].rows = 2;
	m_M[12].columns = 1;
	m_M[13].mat = &m_V[75];		/* Rigid_body\v_xy_CoM\p3.e */
	m_M[13].rows = 2;
	m_M[13].columns = 1;
	m_M[14].mat = &m_R[12];		/* Rigid_body\m_RELbot\p.e */
	m_M[14].rows = 2;
	m_M[14].columns = 1;
	m_M[15].mat = &m_s[12];		/* Rigid_body\m_RELbot\state */
	m_M[15].rows = 2;
	m_M[15].columns = 1;
	m_M[16].mat = &m_I[12];		/* Rigid_body\m_RELbot\state_initial */
	m_M[16].rows = 2;
	m_M[16].columns = 1;
	m_M[17].mat = &m_U[0];		/* m_U1 */
	m_M[17].rows = 2;
	m_M[17].columns = 2;
	m_M[18].mat = &m_U[4];		/* m_U2 */
	m_M[18].rows = 2;
	m_M[18].columns = 2;
	m_M[19].mat = &m_U[8];		/* m_U3 */
	m_M[19].rows = 1;
	m_M[19].columns = 2;
	m_M[20].mat = &m_U[10];		/* m_U4 */
	m_M[20].rows = 1;
	m_M[20].columns = 2;
	m_M[21].mat = &m_U[12];		/* m_U5 */
	m_M[21].rows = 2;
	m_M[21].columns = 1;
	m_M[22].mat = &m_U[14];		/* m_U6 */
	m_M[22].rows = 2;
	m_M[22].columns = 2;
	m_M[23].mat = &m_U[18];		/* m_U7 */
	m_M[23].rows = 2;
	m_M[23].columns = 2;


	/* (re-)initialize the integration method */
	myintegmethod.Initialize(this);
	
	/* copy the inputs */
	m_time = t;
	CopyInputsToVariables (u);

	/* calculate initial equations */
	CalculateInitial ();

	/* set the states again, they might have changed in the initial calculation */
	m_s[0] = m_I[0];		/* Drivetrain_left\Integrate\output */
	m_s[1] = m_I[1];		/* Drivetrain_left\J_rotor_left\state */
	m_s[2] = m_I[2];		/* Drivetrain_right\Integrate\output */
	m_s[3] = m_I[3];		/* Drivetrain_right\J_rotor_right\state */
	m_s[4] = m_I[4];		/* Rigid_body\AngleBody\output {rad} */
	m_s[5] = m_I[5];		/* Rigid_body\c_x_left\state */
	m_s[6] = m_I[6];		/* Rigid_body\c_x_right\state */
	m_s[7] = m_I[7];		/* Rigid_body\c_y_left\state */
	m_s[8] = m_I[8];		/* Rigid_body\c_y_right\state */
	m_s[9] = m_I[9];		/* Rigid_body\InertialPosition\initial1_int */
	m_s[10] = m_I[10];		/* Rigid_body\InertialPosition\initial2_int */
	m_s[11] = m_I[11];		/* Rigid_body\J_RELbot\state */
	m_s[12] = m_I[12];		/* Rigid_body\m_RELbot\state */
	m_s[13] = m_I[13];


	/* calculate static equations */
	CalculateStatic ();
	/* calculate input equations */
	CalculateInput ();
	/* calculate dynamic equations */
	CalculateDynamic ();
	/* calculate output equations */
	CalculateOutput ();

	/* Set the outputs */
	CopyVariablesToOutputs (y);

	/* end of initialization phase */
	m_initialize = false;

	state = mainrun;
}

/* the function that calculates the submodel */
void Plant::Calculate (XXDouble *u, XXDouble *y /*, XXDouble t*/)
{
	switch (state)
	{
		case initialrun:	/* calculate the model for the first time */
			Initialize(u, y, 0.0);
			break;
		case mainrun:	/* calculate the model */
			if ( ( m_time <= (m_finish_time - m_step_size  + c_delta )) || ( m_finish_time == 0.0 ) )
			{
				/* another precessor submodel could determine the parameters of this submodel
				   and therefore the static parameter calculations need to be performed. */
				CalculateStatic ();
				CopyInputsToVariables (u);
				CalculateInput ();
				myintegmethod.Step();
				CalculateOutput ();
				CopyVariablesToOutputs (y);
			}
			else
			{
				state = finished;
			}

			if ( ( m_stop_run == true ) || (( m_finish_time != 0.0 ) && ( m_time + c_delta >= m_finish_time)) )
			{
				state = finished;
			}
			break;
		case finished:
			break;
		default:
			break;
	}
}

/* the termination function for submodel */
void Plant::Terminate (XXDouble *u, XXDouble *y /*, XXDouble t */)
{
	/* copy the inputs */
	CopyInputsToVariables (u);

	/* calculate the final model equations */
	CalculateFinal ();

	/* set the outputs */
	CopyVariablesToOutputs (y);
}


/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void Plant::CalculateInitial (void)
{
		/* Drivetrain_left\Gain\K = (((real) 361 / 5625) * 0.101) / 2; */
		m_P[2] = (((XXDouble) 361.0 / 5625.0) * 0.101) / 2.0;

		/* Drivetrain_left\J_rotor_left\i = (1.49e-6 + (4.28e-4 + (0.02358) * 0.0505 ^ 2) * ((real) 361 / 5625) ^ 2); */
		m_P[4] = (1.49e-6 + (4.28e-4 + (0.02358) * (0.0505 * 0.0505)) * XXPow2 (((XXDouble) 361.0 / 5625.0)));

		/* Drivetrain_left\tf_gearbox_reduction_left\r = (real) 361 / 5625; */
		m_P[7] = (XXDouble) 361.0 / 5625.0;

		/* Drivetrain_right\Gain\K = (((real) 361 / 5625) * 0.101) / 2; */
		m_P[10] = (((XXDouble) 361.0 / 5625.0) * 0.101) / 2.0;

		/* Drivetrain_right\J_rotor_right\i = (1.49e-6 + (4.28e-4 + (0.02358) * 0.0505 ^ 2) * ((real) 361 / 5625) ^ 2); */
		m_P[12] = (1.49e-6 + (4.28e-4 + (0.02358) * (0.0505 * 0.0505)) * XXPow2 (((XXDouble) 361.0 / 5625.0)));

		/* Drivetrain_right\tf_gearbox_reduction_right\r = (real) 361 / 5625; */
		m_P[15] = (XXDouble) 361.0 / 5625.0;

		/* Rigid_body\tf_wheel_left_wrt_CoM\r = [-0.104 - ly_offset; 0.04175 + lx_offset]; */
		m_M[10].mat[0] = -0.104 - m_P[26];
		m_M[10].mat[1] = 0.04175 + m_P[27];

		/* Rigid_body\tf_wheel_right_wrt_CoM\r = [0.104 - ly_offset; 0.04175 + lx_offset]; */
		m_M[12].mat[0] = 0.104 - m_P[26];
		m_M[12].mat[1] = 0.04175 + m_P[27];

		/* Wheel_left\tf_rotation_to_translation_left\r = 0.101 / 2; */
		m_P[33] = 0.101 / 2.0;

		/* Wheel_right\tf_rotation_to_translation_right\r = 0.101 / 2; */
		m_P[35] = 0.101 / 2.0;

}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void Plant::CalculateStatic (void)
{
	/* Drivetrain_left\DeadZone1\halfzone = 0.5 * Drivetrain_left\DeadZone1\zone; */
	m_V[1] = 0.5 * m_P[0];

	/* Drivetrain_right\DeadZone2\halfzone = 0.5 * Drivetrain_right\DeadZone2\zone; */
	m_V[13] = 0.5 * m_P[8];

	/* Rigid_body\m_RELbot\i = [Rigid_body\m_RELbot\m, 0.0; 0.0, Rigid_body\m_RELbot\m]; */
	m_M[2].mat[0] = m_P[21];
	m_M[2].mat[1] = 0.0;
	m_M[2].mat[2] = 0.0;
	m_M[2].mat[3] = m_P[21];

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void Plant::CalculateInput (void)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void Plant::CalculateDynamic (void)
{
	/* Drivetrain_left\Integrate\input = Drivetrain_left\J_rotor_left\state / Drivetrain_left\J_rotor_left\i; */
	m_R[0] = m_s[1] / m_P[4];

	/* Drivetrain_right\Integrate\input = Drivetrain_right\J_rotor_right\state / Drivetrain_right\J_rotor_right\i; */
	m_R[2] = m_s[3] / m_P[12];

	/* Rigid_body\c_x_left\p.e = Rigid_body\c_x_left\state / Rigid_body\c_x_left\spring; */
	m_V[24] = m_s[5] / m_P[16];

	/* Rigid_body\c_x_right\p.e = Rigid_body\c_x_right\state / Rigid_body\c_x_right\spring; */
	m_V[25] = m_s[6] / m_P[17];

	/* Rigid_body\c_y_left\p.e = Rigid_body\c_y_left\state / Rigid_body\c_y_left\spring; */
	m_V[26] = m_s[7] / m_P[18];

	/* Rigid_body\c_y_right\p.e = Rigid_body\c_y_right\state / Rigid_body\c_y_right\spring; */
	m_V[27] = m_s[8] / m_P[19];

	/* Rigid_body\InertialPosition\output = [Rigid_body\InertialPosition\initial1_int; Rigid_body\InertialPosition\initial2_int]; */
	m_M[0].mat[0] = m_s[9];
	m_M[0].mat[1] = m_s[10];

	/* Rigid_body\AngleBody\input = Rigid_body\J_RELbot\state / Rigid_body\J_RELbot\i; */
	m_R[4] = m_s[11] / m_P[20];

	/* Rigid_body\m_RELbot\p.f = inverse (Rigid_body\m_RELbot\i) * Rigid_body\m_RELbot\state; */
	XXMatrixInverse (&m_M[17], &m_M[2], m_workarray);
	/* Rigid_body\m_RELbot\p.f = inverse (Rigid_body\m_RELbot\i) * Rigid_body\m_RELbot\state; */
	XXMatrixMul (&m_M[1], &m_M[17], &m_M[15]);

	/* Drivetrain_left\steer_left = steer_left; */
	m_V[11] = m_V[90];

	/* Drivetrain_right\steer_right = steer_right; */
	m_V[23] = m_V[91];

	/* Drivetrain_left\Gain\output = Drivetrain_left\Gain\K * Drivetrain_left\Integrate\output; */
	m_V[3] = m_P[2] * m_s[0];

	/* Drivetrain_right\Gain\output = Drivetrain_right\Gain\K * Drivetrain_right\Integrate\output; */
	m_V[15] = m_P[10] * m_s[2];

	/* [Rigid_body\Demux\output1; Rigid_body\Demux\output2] = Rigid_body\InertialPosition\output; */
	m_V[28] = m_M[0].mat[0];
	m_V[29] = m_M[0].mat[1];

	/* Drivetrain_left\DeadZone1\output = if Drivetrain_left\steer_left > Drivetrain_left\DeadZone1\halfzone... ; */
	m_V[0] = ((m_V[11] > m_V[1]) ? 
		/* Drivetrain_left\steer_left - Drivetrain_left\DeadZone1\halfzone */
		(m_V[11] - m_V[1])
	:
		/* if Drivetrain_left\steer_left < -Drivetrain_left\DeadZone1\halfzone...  */
		((m_V[11] < -m_V[1]) ? 
			/* Drivetrain_left\steer_left + Drivetrain_left\DeadZone1\halfzone */
			(m_V[11] + m_V[1])
		:
			/* 0.0 */
			0.0
		)
	);

	/* Drivetrain_left\gy_motor_constant_left\p1.u = Drivetrain_left\gy_motor_constant_left\r * Drivetrain_left\Integrate\input; */
	m_V[4] = m_P[3] * m_R[0];

	/* Drivetrain_left\R_rotational_friction_left\p.e = Drivetrain_left\R_rotational_friction_left\r * Drivetrain_left\Integrate\input; */
	m_V[8] = m_P[6] * m_R[0];

	/* Drivetrain_left\tf_gearbox_reduction_left\p2.f = Drivetrain_left\tf_gearbox_reduction_left\r * Drivetrain_left\Integrate\input; */
	m_V[10] = m_P[7] * m_R[0];

	/* Drivetrain_right\DeadZone2\output = if Drivetrain_right\steer_right > Drivetrain_right\DeadZone2\halfzone... ; */
	m_V[12] = ((m_V[23] > m_V[13]) ? 
		/* Drivetrain_right\steer_right - Drivetrain_right\DeadZone2\halfzone */
		(m_V[23] - m_V[13])
	:
		/* if Drivetrain_right\steer_right < -Drivetrain_right\DeadZone2\halfzone...  */
		((m_V[23] < -m_V[13]) ? 
			/* Drivetrain_right\steer_right + Drivetrain_right\DeadZone2\halfzone */
			(m_V[23] + m_V[13])
		:
			/* 0.0 */
			0.0
		)
	);

	/* Drivetrain_right\gy_motor_constant_right\p1.u = Drivetrain_right\gy_motor_constant_right\r * Drivetrain_right\Integrate\input; */
	m_V[16] = m_P[11] * m_R[2];

	/* Drivetrain_right\R_rotational_friction_right\p.e = Drivetrain_right\R_rotational_friction_right\r * Drivetrain_right\Integrate\input; */
	m_V[20] = m_P[14] * m_R[2];

	/* Drivetrain_right\tf_gearbox_reduction_right\p2.f = Drivetrain_right\tf_gearbox_reduction_right\r * Drivetrain_right\Integrate\input; */
	m_V[22] = m_P[15] * m_R[2];

	/* new_rate = Rigid_body\m_RELbot\p.f[1,1]; */
	m_R[9] = m_M[1].mat[0];

	/* new_rate = Rigid_body\m_RELbot\p.f[2,1]; */
	m_R[10] = m_M[1].mat[1];

	/* Rigid_body\RTF\r = [cos (Rigid_body\AngleBody\output), -sin (Rigid_body\AngleBody\output); sin (Rigid_body\AngleBody\output), cos (Rigid_body\AngleBody\output)]; */
	m_M[8].mat[0] = cos (m_s[4]);
	m_M[8].mat[1] = -(sin (m_s[4]));
	m_M[8].mat[2] = sin (m_s[4]);
	m_M[8].mat[3] = cos (m_s[4]);

	/* Rigid_body\RTF\p1.f = (1.0 / Rigid_body\RTF\r) * Rigid_body\m_RELbot\p.f; */
	XXScalarMatrixDiv (&m_M[18], 1.0, &m_M[8], m_workarray);
	/* Rigid_body\RTF\p1.f = (1.0 / Rigid_body\RTF\r) * Rigid_body\m_RELbot\p.f; */
	XXMatrixMul (&m_M[7], &m_M[18], &m_M[1]);

	/* Rigid_body\tf_wheel_left_wrt_CoM\p2.f = Rigid_body\tf_wheel_left_wrt_CoM\r * Rigid_body\AngleBody\input; */
	XXMatrixScalarMul (&m_M[9], &m_M[10], m_R[4]);

	/* Rigid_body\tf_wheel_right_wrt_CoM\p2.f = Rigid_body\tf_wheel_right_wrt_CoM\r * Rigid_body\AngleBody\input; */
	XXMatrixScalarMul (&m_M[11], &m_M[12], m_R[4]);

	/* Drivetrain_left\DutycycleToVolt\output = Drivetrain_left\DutycycleToVolt\K * Drivetrain_left\DeadZone1\output; */
	m_V[2] = m_P[1] * m_V[0];

	/* Drivetrain_right\DutycycleToVolt\output = Drivetrain_right\DutycycleToVolt\K * Drivetrain_right\DeadZone2\output; */
	m_V[14] = m_P[9] * m_V[12];

	/* [Rigid_body\PowerDemuxLeft\output1.f; Rigid_body\PowerDemuxLeft\output2.f] = Rigid_body\tf_wheel_left_wrt_CoM\p2.f; */
	m_V[43] = m_M[9].mat[0];
	m_V[46] = m_M[9].mat[1];

	/* [Rigid_body\PowerDemuxRight\output1.f; Rigid_body\PowerDemuxRight\output2.f] = Rigid_body\tf_wheel_right_wrt_CoM\p2.f; */
	m_V[51] = m_M[11].mat[0];
	m_V[54] = m_M[11].mat[1];

	/* [Rigid_body\PowerDemuxLeft1\output1.f; Rigid_body\PowerDemuxLeft1\output2.f] = Rigid_body\RTF\p1.f; */
	m_V[47] = m_M[7].mat[0];
	m_V[50] = m_M[7].mat[1];

	/* Drivetrain_left\i_actuator_left\p2.u = Drivetrain_left\DutycycleToVolt\output - Drivetrain_left\gy_motor_constant_left\p1.u; */
	m_V[6] = m_V[2] - m_V[4];

	/* Drivetrain_right\i_actuator_left1\p2.u = Drivetrain_right\DutycycleToVolt\output - Drivetrain_right\gy_motor_constant_right\p1.u; */
	m_V[18] = m_V[14] - m_V[16];

	/* Rigid_body\c_y_left\p.f = Rigid_body\PowerDemuxLeft1\output2.f + Rigid_body\PowerDemuxLeft\output2.f; */
	m_R[7] = m_V[50] + m_V[46];

	/* [Rigid_body\PowerDemuxRight1\output1.f; Rigid_body\PowerDemuxRight1\output2.f] = Rigid_body\RTF\p1.f; */
	m_V[55] = m_M[7].mat[0];
	m_V[58] = m_M[7].mat[1];

	/* Wheel_left\R_rotational_friction_left\p.e = Wheel_left\R_rotational_friction_left\r * Drivetrain_left\tf_gearbox_reduction_left\p2.f; */
	m_V[77] = m_P[32] * m_V[10];

	/* Wheel_left\tf_rotation_to_translation_left\p2.f = Wheel_left\tf_rotation_to_translation_left\r * Drivetrain_left\tf_gearbox_reduction_left\p2.f; */
	m_V[79] = m_P[33] * m_V[10];

	/* Wheel_right\R_rotational_friction_right\p.e = Wheel_right\R_rotational_friction_right\r * Drivetrain_right\tf_gearbox_reduction_right\p2.f; */
	m_V[81] = m_P[34] * m_V[22];

	/* Wheel_right\tf_rotation_to_translation_right\p2.f = Wheel_right\tf_rotation_to_translation_right\r * Drivetrain_right\tf_gearbox_reduction_right\p2.f; */
	m_V[83] = m_P[35] * m_V[22];

	/* Drivetrain_left\R_actuator_left\p.f = Drivetrain_left\i_actuator_left\p2.u / Drivetrain_left\R_actuator_left\r; */
	m_V[7] = m_V[6] / m_P[5];

	/* Drivetrain_right\R_actuator_right\p.f = Drivetrain_right\i_actuator_left1\p2.u / Drivetrain_right\R_actuator_right\r; */
	m_V[19] = m_V[18] / m_P[13];

	/* Rigid_body\c_y_right\p.f = Rigid_body\PowerDemuxRight1\output2.f + Rigid_body\PowerDemuxRight\output2.f; */
	m_R[8] = m_V[58] + m_V[54];

	/* Rigid_body\r_y_left\p.e = Rigid_body\r_y_left\r * Rigid_body\c_y_left\p.f; */
	m_V[67] = m_P[24] * m_R[7];

	/* Drivetrain_left\gy_motor_constant_left\p2.T = Drivetrain_left\gy_motor_constant_left\r * Drivetrain_left\R_actuator_left\p.f; */
	m_V[5] = m_P[3] * m_V[7];

	/* Drivetrain_right\gy_motor_constant_right\p2.T = Drivetrain_right\gy_motor_constant_right\r * Drivetrain_right\R_actuator_right\p.f; */
	m_V[17] = m_P[11] * m_V[19];

	/* Rigid_body\OneJunction12\p2.e = Rigid_body\c_y_left\p.e + Rigid_body\r_y_left\p.e; */
	m_V[39] = m_V[26] + m_V[67];

	/* Rigid_body\r_y_right\p.e = Rigid_body\r_y_right\r * Rigid_body\c_y_right\p.f; */
	m_V[68] = m_P[25] * m_R[8];

	/* Rigid_body\c_x_left\p.f = (Rigid_body\PowerDemuxLeft1\output1.f + Rigid_body\PowerDemuxLeft\output1.f) - Wheel_left\tf_rotation_to_translation_left\p2.f; */
	m_R[5] = (m_V[47] + m_V[43]) - m_V[79];

	/* Rigid_body\c_x_right\p.f = (Rigid_body\PowerDemuxRight1\output1.f + Rigid_body\PowerDemuxRight\output1.f) + Wheel_right\tf_rotation_to_translation_right\p2.f; */
	m_R[6] = (m_V[55] + m_V[51]) + m_V[83];

	/* Rigid_body\OneJunction13\p2.e = Rigid_body\c_y_right\p.e + Rigid_body\r_y_right\p.e; */
	m_V[40] = m_V[27] + m_V[68];

	/* Rigid_body\r_x_left\p.e = Rigid_body\r_x_left\r * Rigid_body\c_x_left\p.f; */
	m_V[65] = m_P[22] * m_R[5];

	/* Rigid_body\r_x_right\p.e = Rigid_body\r_x_right\r * Rigid_body\c_x_right\p.f; */
	m_V[66] = m_P[23] * m_R[6];

	/* Rigid_body\OneJunction8\p1.e = Rigid_body\r_x_left\p.e + Rigid_body\c_x_left\p.e; */
	m_V[41] = m_V[65] + m_V[24];

	/* Rigid_body\OneJunction9\p1.e = Rigid_body\r_x_right\p.e + Rigid_body\c_x_right\p.e; */
	m_V[42] = m_V[66] + m_V[25];

	/* Rigid_body\OneJunction\p2.e = -Rigid_body\OneJunction8\p1.e; */
	m_V[38] = -m_V[41];

	/* Rigid_body\PowerDemuxLeft\input.e = [Rigid_body\OneJunction8\p1.e; Rigid_body\OneJunction12\p2.e]; */
	m_M[3].mat[0] = m_V[41];
	m_M[3].mat[1] = m_V[39];

	/* Rigid_body\PowerDemuxLeft1\input.e = [Rigid_body\OneJunction8\p1.e; Rigid_body\OneJunction12\p2.e]; */
	m_M[4].mat[0] = m_V[41];
	m_M[4].mat[1] = m_V[39];

	/* Rigid_body\PowerDemuxRight\input.e = [Rigid_body\OneJunction9\p1.e; Rigid_body\OneJunction13\p2.e]; */
	m_M[5].mat[0] = m_V[42];
	m_M[5].mat[1] = m_V[40];

	/* Rigid_body\PowerDemuxRight1\input.e = [Rigid_body\OneJunction9\p1.e; Rigid_body\OneJunction13\p2.e]; */
	m_M[6].mat[0] = m_V[42];
	m_M[6].mat[1] = m_V[40];

	/* Rigid_body\tf_wheel_left_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_left_wrt_CoM\r) * Rigid_body\PowerDemuxLeft\input.e; */
	XXMatrixTranspose (&m_M[19], &m_M[10]);
	/* Rigid_body\tf_wheel_left_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_left_wrt_CoM\r) * Rigid_body\PowerDemuxLeft\input.e; */
	XXScalarMatrixMatrixMul (&m_V[69], &m_M[19], &m_M[3]);

	/* Rigid_body\tf_wheel_right_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_right_wrt_CoM\r) * Rigid_body\PowerDemuxRight\input.e; */
	XXMatrixTranspose (&m_M[20], &m_M[12]);
	/* Rigid_body\tf_wheel_right_wrt_CoM\p1.e = transpose (Rigid_body\tf_wheel_right_wrt_CoM\r) * Rigid_body\PowerDemuxRight\input.e; */
	XXScalarMatrixMatrixMul (&m_V[72], &m_M[20], &m_M[5]);

	/* Rigid_body\v_xy_CoM\p3.e = -(Rigid_body\PowerDemuxRight1\input.e + Rigid_body\PowerDemuxLeft1\input.e); */
	XXMatrixAdd (&m_M[21], &m_M[6], &m_M[4]);
	/* Rigid_body\v_xy_CoM\p3.e = -(Rigid_body\PowerDemuxRight1\input.e + Rigid_body\PowerDemuxLeft1\input.e); */
	XXMatrixInv (&m_M[13], &m_M[21]);

	/* Rigid_body\m_RELbot\p.e = (1.0 / transpose (Rigid_body\RTF\r)) * Rigid_body\v_xy_CoM\p3.e; */
	XXMatrixTranspose (&m_M[23], &m_M[8]);
	XXScalarMatrixDiv (&m_M[22], 1.0, &m_M[23], m_workarray);
	/* Rigid_body\m_RELbot\p.e = (1.0 / transpose (Rigid_body\RTF\r)) * Rigid_body\v_xy_CoM\p3.e; */
	XXMatrixMul (&m_M[14], &m_M[22], &m_M[13]);

	/* Rigid_body\J_RELbot\p.e = -(Rigid_body\tf_wheel_left_wrt_CoM\p1.e + Rigid_body\tf_wheel_right_wrt_CoM\p1.e); */
	m_R[11] = -(m_V[69] + m_V[72]);

	/* Wheel_left\tf_rotation_to_translation_left\p1.e = Wheel_left\tf_rotation_to_translation_left\r * Rigid_body\OneJunction\p2.e; */
	m_V[78] = m_P[33] * m_V[38];

	/* Wheel_right\tf_rotation_to_translation_right\p1.e = Wheel_right\tf_rotation_to_translation_right\r * Rigid_body\OneJunction9\p1.e; */
	m_V[82] = m_P[35] * m_V[42];

	/* Wheel_left\w_wheel_left\p1.T = Wheel_left\tf_rotation_to_translation_left\p1.e + Wheel_left\R_rotational_friction_left\p.e; */
	m_V[80] = m_V[78] + m_V[77];

	/* Wheel_right\w_wheel_right\p1.T = Wheel_right\tf_rotation_to_translation_right\p1.e + Wheel_right\R_rotational_friction_right\p.e; */
	m_V[84] = m_V[82] + m_V[81];

	/* Drivetrain_left\tf_gearbox_reduction_left\p1.e = Drivetrain_left\tf_gearbox_reduction_left\r * Wheel_left\w_wheel_left\p1.T; */
	m_V[9] = m_P[7] * m_V[80];

	/* Drivetrain_right\tf_gearbox_reduction_right\p1.e = Drivetrain_right\tf_gearbox_reduction_right\r * Wheel_right\w_wheel_right\p1.T; */
	m_V[21] = m_P[15] * m_V[84];

	/* Drivetrain_left\J_rotor_left\p.e = Drivetrain_left\gy_motor_constant_left\p2.T - (Drivetrain_left\tf_gearbox_reduction_left\p1.e + Drivetrain_left\R_rotational_friction_left\p.e); */
	m_R[1] = m_V[5] - (m_V[9] + m_V[8]);

	/* Drivetrain_right\J_rotor_right\p.e = Drivetrain_right\gy_motor_constant_right\p2.T - (Drivetrain_right\tf_gearbox_reduction_right\p1.e + Drivetrain_right\R_rotational_friction_right\p.e); */
	m_R[3] = m_V[17] - (m_V[21] + m_V[20]);

}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void Plant::CalculateOutput (void)
{
	/* c_position_x = Rigid_body\Demux\output1; */
	m_V[85] = m_V[28];

	/* d_position_y = Rigid_body\Demux\output2; */
	m_V[86] = m_V[29];

	/* a_pos_feedback_left = Drivetrain_left\Gain\output; */
	m_V[87] = m_V[3];

	/* b_pos_feedback_right = Drivetrain_right\Gain\output; */
	m_V[88] = m_V[15];

	/* e_theta_z = Rigid_body\AngleBody\output; */
	m_V[89] = m_s[4];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void Plant::CalculateFinal (void)
{

}



bool Plant::SetFinishTime(XXDouble newtime)
{
	if ((newtime <= 0.0) || ( newtime > m_time))
	{
		m_finish_time = newtime;
		return true;
	}

	return false;
}

